[
  {
    "title": "플립 시계 만들기 with JS (2020)",
    "summary": "숫자판이 틱,틱 소리를 돌아가며 가벼이 넘어간다. 지금 이 순간 흐르는 시간이 내는 소리다. 우리를 둘러싼 수 많은 장치들이 아날로그에서 디지털로 바뀌어 버린것도 이젠 오래 전이 되어버렸다.",
    "link": "https://velog.io/@oneook/%ED%94%8C%EB%A6%BD-%EC%8B%9C%EA%B3%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-with-JS-Split-Flap-Project",
    "img_link": "https://media.vlpt.us/images/oneook/post/845a4a59-41a2-4bb9-a80a-af474fec65d7/flip.gif?w=768",
    "content": "플립 시계 만들기\n아날로그를 닮고 싶은 디지털 🕰\n숫자판이 틱,틱 소리를 내며 가벼이 넘어간다. 지금 이 순간 흐르는 시간이 내는 소리다. 우리를 둘러싼 수 많은 장치들이 아날로그에서 디지털로 바뀌어 버린것도 이젠 오래 전이 되어버렸다. 시대가 변하고 우리는 새로운 세상에 완전히 적응해버린 듯 해도 문득 아날로그만의 독특한 감성의 결이 그리워진다.\n스플릿 플랩 디스플레이(Split-Flap Display)라고 불리는 우리에게 익숙한 이 기계적 표현 방식은 실용성과는 거리가 있지만 디지털 인터페이스 시대에도 즐겨 사용되는 UI 중 하나이다.\n스플릿 플랩 디스플레이로 표현된 시계는 어떻게 만들 수 있을까? 호기심이 나를 이끌었었다. 한 해 전 취미 삼아 가볍게 배웠던 자바스크립트로 만든 나의 작고 보잘 것 없는 장난감을 소개한다.\n지금 보면 바보같은 코드이기 때문에 혹여라도 참고하지 않으셨으면 좋겠다.\n이 글은 '제가 이런걸 만들었습니다 여러분!' 보단 '이런걸 만들기도 했었지요.'에 가깝다\n\n\n매커니즘 ⚙️\n메커니즘은 매우 간단하다. 구동 축이 동일한 방향으로, 매 초마다 입력을 받아서 설정된 각도만큼 회전하며, 궤도에 연결된 숫자판(Flap)이 하나씩 뒤집어지면서 다음 숫자를 보여준다.\n각 숫자판은 반으로 쪼개져 있으며, 뒷면엔 다음 숫자의 절반이 표시되어 있다.\n외부에서 보여지는 물리적 동작만 화면으로 표현하기 위해 아래와 같이 규칙을 정했다.\n규칙\n각 플랩은 0부터 9까지 구성되어있으며 오름차순으로 표시된다.\n컴포넌트 별 최대 표시값 : Hour = 24, Min = 60, Sec = 60이며 최대 값을 넘기면 상위 파트의 숫자가 증가한다. (플립 UI작동)\n최대값을 초과하면 다시 0으로 리셋된다.\n제일 작은 표시 단위인 오른쪽 Sec 플랩에만 Date 객체의 값을 전달하고, setInterval 함수로 구동한다.\n\n\n구성 🎛\n크게 시, 분, 초로 나누고 Upper-Left / Lower-Left / Upper-Right / Lower-Right로 플랩을 나눈다.\n보일지 모르겠지만 DOM node Assigning을 보면 각 플랩마다 요소가 한 개 더 있는것을 볼 수 있다.\n숫자판이 내려오면서 Upper Plate는 다음 숫자가 보이고, Lower Plate는 플립 애니메이션이 끝날때 까지 현재 숫자를 유지해야 하는 엇박자를 해결해야 했다. 그래서 매 초마다 보여져야 할 숫자를 표시하는 Backplate와 플립 애니메이션 효과를 위한 Foreplate로 레이어를 나눴다.\n\n\n구현 🎶\n\nImage vs Number\n각 숫자를 반으로 나눈 이미지들을 준비해서 매 초마다 img 태그 source의 주소값을 데이터셋을 참조하여 바꿔줄까 고민했지만, 결정적으로 이미지는 CSS 애니메이션 중 RotateX 효과에 적합하지 않았던 것으로 기억한다.\n이미지 대신 Number를 그대로 표현하기로 했으며, 간결한 레터 레이아웃을 위해 Helvetica로 자간을 맞춰가며 적용했다.\n\nLogic\n지금 보면 setInterval에 욱여 넣은 무지막지한 코드 블럭이지만..\n설명하자면 Date 객체로부터 시간 단위별 값을 가져오는 것으로 시작한다. 한 자리 단위일 때 앞에 무조건 0이 붙어야 해서 10시 이전에는 강제로 0을 붙였다. 그땐 24시간제로 값을 가져올 수 있는 걸 몰랐었다.\n1초마다 시간을 가져오다가 타이밍이 어긋나는 경우가 있어서 Interval은 500ms 간격으로 설정했다.\nlet h0, h1, m0, m1, s0, s1, hDigit, minDigit, secDigit;\n\nconst realTime = setInterval(() => {\n  const getTime = new Date();\n\n  // HOUR\n  const hour = getTime.getHours();\n  hDigit = hour.toString();\n  h0 = hDigit.charAt(0);\n  h1 = hDigit.charAt(1);\n  if (hDigit < 10) {\n    h0 = 0;\n    h1 = hDigit;\n  }\n\n  // MIN\n  const min = getTime.getMinutes();\n  minDigit = min.toString();\n  m0 = minDigit.charAt(0);\n  m1 = minDigit.charAt(1);\n  if (minDigit < 10) {\n    m0 = 0;\n    m1 = minDigit;\n  }\n\n  // SEC\n  const sec = getTime.getSeconds();\n  secDigit = sec.toString();\n  s0 = secDigit.charAt(0);\n  s1 = secDigit.charAt(1);\n  if (secDigit < 10) {\n    s0 = 0;\n    s1 = secDigit;\n  }\n}, 500);\n아래는 숫자가 바뀔때마다 플랩 애니메이션을 적용하고 해제하기 위한 클래스 토글 함수다.\n// FLIP UI\nconst flipUI = (ele1, ele2) => {\n  ele1.classList.remove('active');\n  ele2.classList.remove('active');\n  void ele1.offsetWidth;\n  void ele2.offsetWidth;\n  ele1.classList.add('active');\n  ele2.classList.add('active');\n}\nsetInterval의 향연..\n각 단위별 로직이 조금씩 다르지만 부끄러워서 Sec 로직만 적었다. 각 숫자 단위가 어떻게 달라지는지에 따라 표현을 조건별로 분기하여 나름 애썼던 모습이 보인다.\n// SEC FLIPPER\nconst countSec = setInterval(() => {\n  if (s1 != 0) {\n    flipUI(upFlipSecR, loFlipSecR);\n  } else {\n    flipUI(upFlipSecL, loFlipSecL);\n    flipUI(upFlipSecR, loFlipSecR);\n  }\n  if (s1 % 10 === 0) {\n    flipUI(upFlipSecL, loFlipSecL);\n  }\n  upSecL.textContent = s0;\n  loFlipSecL.textContent = s0;\n  upSecR.textContent = s1;\n  loFlipSecR.textContent = s1;\n  delaySec(s0, s1);\n}, 1000)\n\nconst delaySec = function (c, d) {\n  setTimeout(() => {\n    upFlipSecL.textContent = c;\n    loSecL.textContent = c;\n    upFlipSecR.textContent = d;\n    loSecR.textContent = d;\n  }, 800);\n}\n\n\n테스트 및 최종 적용\n자연스럽게 앞 자리 단위가 오르는 것을 보고 즐거워했던 생각이 난다. 플랩이 회전하는 효과는 CSS rotateX를 사용했고 원근감 효과를 위해 perspective 프로퍼티를 사용했다.\n시간은 쉼없이 멈추지 않고 흐른다. 하나씩 덮혀가는 플랩들을 바라보면 추억도 한꺼풀씩 다른 기억들로 덮여가는 느낌을 받는다.\n\n\n글과 그림 ⓒ Wonkook Lee\n🙏🏻 잘못된 정보가 있다면 지적해주세요"
  },
  {
    "title": "Work In Progress - 위스타벅스 ☕️ 페이지 클론 기록하기 (2)",
    "summary": "인스타그램, 스타벅스의 일부 페이지를 모방하며 실제 페이지의 구성과 기능을 따라하고 웹 페이지 제작에 대한 이해를 높이는 학습 과정으로서 위스타벅스 제작, 두번째 이야기.",
    "link": "https://velog.io/@oneook/Work-In-Progress-%EC%9C%84%EC%8A%A4%ED%83%80%EB%B2%85%EC%8A%A4-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%81%B4%EB%A1%A0-%EA%B8%B0%EB%A1%9D%ED%95%98%EA%B8%B0-2",
    "img_link": "https://media.vlpt.us/images/oneook/post/b537ef04-e202-42ff-8261-cbb426bea7c5/westabucks3.jpg?w=768",
    "content": "Work In Progress Aug 26\n\n# 개요 📋\n과제명 : 위스타벅스 (Westabucks)\n제작 : WONKOOK LEE\n분류 : 학습용 과제\n제작 기간 : 2021.08.23 - 08.26\n목적 : 시맨틱 HTML 학습, 유저 입력 유효성 검증, UI 조작, 기능 구현\n사용 툴 : HTML, CSS, JavaScript\n데모 :\n위스타벅스: 로그인 페이지\n위스타벅스: 음료 리스트 페이지\n위스타벅스: 음료 상세 페이지\n\n# 넘나 바쁜 당신을 위한 단락 바로가기 🚗\n# checkbox로 토글 UI 만들기 ✅\n# 댓글 창 흉내 내기 💬\n# 반응형 레이아웃 📏\n# 리다이렉트 🔗\n# 리팩토링 🛠\n\n\n# Overview 👀\n인스타그램, 스타벅스의 일부 페이지를 모방하며 실제 페이지의 구성과 기능을 따라하고 웹 페이지 제작에 대한 이해를 높이는 학습 과정으로서 위스타벅스 제작이 진행됐다.\n인스타그램의 로그인 페이지에선 사용자의 입력값 Validation과 기대한 값이 들어왔을 때 Valid UI를 표현하는 것을 목표로 만들었다.\n스타벅스의 음료 상세 페이지의 기존 구성과 기능(레이아웃 + 줌 인터랙션)에 더하여 '좋아요' toggle UI와 댓글 창(UI Mockup)을 추가 구현하였다. 줌 인터랙션은 이 포스트를 참고\n스타벅스의 음료 목록 페이지는 제품 리스트의 그리드 구성 및 media query와 flex 프로퍼티를 사용한 반응형 웹을 공부하기 위한 목표로 만들었다.\n각 페이지에서 공부한 내용을 기능, 맥락 별로 나열하여 설명한다.\n\n\n# checkbox로 토글 UI 만들기 ✅\ninput 타입 중 checkbox로도 토글 UI를 만들 수 있다. 예를 들어 좋아요 하트가 꺼졌다 켜지는 등 간단한 UI는 자바스크립트 없이 CSS 만으로 충분히 구현이 가능하다. 클릭 이벤트 리스너를 모든 요소에 일일히 위임하지 않아도 인터랙션이 작동되기 때문에 checkbox 트릭은 자주 사용되는 방법이다.\n<input type=\"checkbox\" name=\"like_bev\" id=\"like_bev\">\n<i class=\"far fa-heart\"></i>\n<i class=\"fas fa-heart\"></i>\n\n## CSS는 checkbox의 체크 여부를 알 수 있다 🔎\ncheckbox는 체크가 된 상태와 체크가 되지 않은 상태, 두 가지로 나뉜다. 이는 값으로도 나타낼 수 있으며 CSS에서 가상 선택자로서 체크된 상태를 아래와 같이 참조할 수 있다.\n#like_bev:checked { ...styles }\n이로써 체크가 표시된 checkbox에 한하여 특정 스타일을 적용할 수 있다. 나는 checkbox는 사용자가 클릭했는지 여부만 전달하고 스타일 변경은 형제 요소에게 위임하는 방법을 사용했다.\n  #like_bev_container #like_bev:checked ~ .far {\n    opacity: 0;\n  }\n\n  #like_bev_container #like_bev:checked + i {\n    opacity: 1;\n  }\n\n## 두근두근 깨알 같은 마이크로 인터랙션 ❤️\n이전 포스트에서도 언급했듯 나는 깨알같은 디테일을 사랑하기 때문에 좋아요가 눌러지는 순간 두근두근 하는 애니메이션이 작동되도록 키프레임을 설정해놓았다.\n  #like_bev_container #like_bev:checked ~ .fas {\n    color: crimson;\n    opacity: 1;\n    animation-name: heartbeat;\n    animation-duration: 1s;\n    animation-timing-function: ease;\n    animation-fill-mode: forwards;\n  }\n  \n    @keyframes heartbeat {\n    0% {transform: scale(1);opacity: 0;}\n    25% {transform: scale(1.3);}\n    50% {transform: scale(1);opacity: 1;}\n    75% {transform: scale(1.3);}\n    100% {transform: scale(1);}\n  }\n\n## 요소가 겹칠 땐 z-index를 활용하자 🏗\nFont Awesome에서 가져온 i 태그 두 개를 겹쳐놓고, checkbox가 체크되지 않았을 땐 속이 빈 하트가 표시되며, 체크되었을 땐 속이 찬 하트가 애니메이션과 함께 보이도록 display 또는 opacity를 사용해주면 된다.\n여기서 주의할 점은 여러 요소를 겹쳐놓을 경우 input 태그는 z-index 값을 상대적으로 높여 클릭을 인식할 수 있도록 만들어주어야 하는 점이다.\n\n\n# 댓글 창 흉내 내기 💬\n원본 사이트에는 없는 댓글 창 UI를 만들게 되었다. 과제는 댓글 추가와 삭제였지만 최소 열자 이상 작성해야 댓글을 달 수 있는 알림 UI도 만들어봤다. DOM으로 HTML 요소만 추가되고 삭제되는 UI 목업이며 CRUD가 아니기 때문에 흉내냈다고 표현했다. 다른 유저 댓글을 지워버리는 것 자체가..\n\n## 댓글 추가 ⌨️\n변수 html에 HTML 태그 뭉치를 넣고, 아이디와 댓글 내용만 바꾸어 insertAdjacentHTML로 댓글 리스트에 새로운 li 요소로써 추가하는 방법을 사용했다. 나는 document.createElement()로 DOM 요소를 만들어 prepend 또는 append하는 방법보다 태그를 직접 삽입하는 편이 간편해서 더 선호한다.\n본래 의도는 새로 생성되는 댓글 스레드의 배경색을 번갈아가며 생성되도록 만들고자 하였지만, nth-child(odd)로 CSS 스타일 처리만 했다. 댓글이 많아져서 레이아웃이 깨지지 않도록 overflow-y: scroll를 사용하여 창을 스크롤로 만들었다.\nuserComment.length < 10을 넣어 댓글의 글자수가 10글자가 이하라면 Guard Clause로 예외 처리 되도록 만들었다.\ninvalidAlert()는 유저에게 왜 댓글이 작성되지 않는지 알려주는 UI 조작 함수다.\nconst reviewInputField = document.getElementById('review_field');\n  \nconst addComment = (event, userName='oneook', userComment) => {\n  event.preventDefault();\n  if (userComment.length < 10) {\n    invalidAlert();\n    return;\n  };\n\n  let html = `<li class=\"review_thread\"><span class=\"id\">${userName}</span><span class=\"comment\">${userComment}</span><div id=\"closeBtn\">X</div></li>`;\n  document.getElementById('RvTarget').insertAdjacentHTML('afterbegin', html);\n\n  reviewInputField.value = '';\n}\n\nreviewInputField.addEventListener('keypress', (event) => {\n  event.key === 'Enter' && addComment(event, undefined, event.target.value);\n})\n\n## 댓글 최소 글자수 제한 🚫\n댓글 글자수를 충족하지 못하면 알림 UI가 발생된다. 시간이 흐르면 천천히 사라지는 모습을 연출하기 위해 애니메이션을 사용했고, 애니메이션이 끝난 후 프로퍼티를 기본값으로 되돌리기 위해 setTimeout을 사용했다.\nconst validTag = document.getElementById('validTag');\n\nconst invalidAlert = () => {\n  validTag.style.animationName = 'notValid';\n  setTimeout(() => { validTag.style.animationName = '' }, 1500);\n}\n조작이 이루어지는 영역이 아니기 때문에 간단히 투명도만 조절되는 애니메이션을 넣었다.\n@keyframes notValid {\n  0% { opacity: 0; }\n  10% { opacity: 1; }\n  60% { opacity: 1; }\n  100% { opacity: 0; }\n}\n\n## 댓글 삭제 🗑\n댓글 삭제 버튼은 삭제할 댓글 스레드에 커서를 올려(Hovering)야 비로소 보이게 만들어봤다. 댓글을 삭제할 수 있다는 것은 확실히 알려주고 싶은데 노멀 상태의 UI가 복잡해지는건 원치 않았다. 삭제 버튼과 댓글 사이에 거리가 있기 때문에 Hover시 스레드의 색상을 다르게 바꾸어 어떤 스레드를 지우는지 명확하게 알려주고자 하였다.\n// Delete Comment\n\nconst deleteComment = (function() {\n  const reviewField = document.getElementById('RvTarget');\n\n  reviewField.addEventListener('click', event => {\n    if (event.target.id !== 'deleteBtn') return;\n    event.target.closest('.review_thread').remove();\n  })\n\n})();\n리뷰 스레드를 포괄하는 ul인 RvTarget에 하나의 이벤트 핸들러를 걸고 삭제 버튼에 이벤트를 위임했다. 버튼을 클릭하면 버튼이 포함된 부모 요소 중 li 요소인 review_thread를 지우도록 만들었다. closest()는 자신을 포함한 부모, 조상 요소 중 해당 선택자(querySelector처럼 작동한다)를 가진 첫번째 요소(Upward)를 선택한다. DOM Traversing 메소드 중 가장 유용하게 사용되는 메소드다.\n\n\n# 반응형 레이아웃 📏\n스타벅스 홈페이지는 반응형으로 설계되어있다. 데스크탑, 태블릿, 스마트폰 순으로 break point가 존재하며, 960px보다 뷰포트가 작아지면 GNB는 숨겨지고 태블릿, 스마트폰용 UI(햄버거 메뉴 등)로 전환된다. 음료 목록 그리드는 flex를 사용하여 길이가 줄어들면 wrap 되어 다음 행으로 컴포넌츠를 보내도록 만들었다.\n## 미디어 쿼리 ＠\n현재까지 구현한 사이즈 별 쿼리는 다음과 같다. 중간 중간 로고가 찝히거나 구성이 애매한 경우를 대비해서 겹치는 구간도 스타일을 넣어주었다.\n@media (min-width: 961px) { ... }\n@media screen and (min-width: 961px) and (max-width: 1099px) { ... }\n@media screen and (min-width: 481px) and (max-width: 960px) { ... }\n@media screen and (min-width: 641px) and (max-width: 960px) { ... }\n@media screen and (min-width: 481px) and (max-width: 660px) { ... }\n\n\n# 리다이렉트 🔗\nanchor 태그를 넣기 애매했던 form 속의 button는 JS에서 페이지 이동 메소드를 사용했다. location.href와 location.replace 두 가지 메소드가 있는데, 차이점은 아래와 같다.\n\n## relocation.replace와 relocation.href의 차이\n\nlocation.href location.replace\n기능 새로운 페이지로 이동된다. 기존 페이지를 새로운 페이지로 변경시킨다.\n형태 프로퍼티 메소드\n주소 히스토리 기록된다 기록되지 않는다.\n사용 예 location.href='abc.php' location.replace('abc.php')\nhref는 페이지를 이동하는 것이기 때문에 이전 페이지로 다시 되돌아갈 수 있지만 (히스토리가 있음) replace는 새로운 페이지로 덮어 씌우기 때문에 이전 페이지로 이동이 불가하다.\n하지만 cache가 남지 않고 페이지 요소가 refresh되어야 할 필요성이 있다면 replace가 좋은 방법이 될 것 같다.\n출처\n\n## 그럼에도 <a> 태그를 사용하는 이유\n자바스크립트가 다운되더라도 링크가 작동되기 때문에\n스파이더나 구글 봇들이 자바스크립트를 통해 링크로 침투하는 것을 막기 위해\nwindow.location.href 사용은 비표준 링크로 페이지 간의 연결을 숨기는 것으로써 World Wide Web의 약속에 위배된다.\nUX에도 좋지 않다. 앵커 태그로 작성된 링크는 마우스를 가져가면 status bar에 링크를 표시하거나, 링크를 복사하고, 새로운 탭에서 여는 등 다양한 인터랙션이 가능하다. 반면 window.location는 그런 UX적인 면에서 기존 앵커 태그보다 뒤쳐진다.\n훨씬 쉽기 때문에 좋다.\n\n\n# 리팩토링 🛠\n왜 커밋, 푸시하고 나서야 다른 문제점이 눈에 보이는 걸까? 무한 푸시\n코드 리뷰에서 지적받은 점과 스스로 고친 것들을 적는다.\n## CSS 리팩토링\n\n### CSS 속성 작성 순서는 레이아웃에 영향을 많이 주는 순서대로, 인접 속성끼리 묶어서 작성할 것\n같은 선택자 내 CSS 속성 작성 순서 (권장)\nLayout Properties (position, float, clear, display)\nBox Model Properties (width, height, margin, padding)\nVisual Properties (color, background, border, box-shadow)\nTypography Properties (font-size, font-family, text-align, text-transform)\nMisc Properties (cursor, overflow, z-index)\n매번 CSS 작성할 때마다 display, position 관련 속성을 제외하고선 생각나는대로 적어서 항상 다시 찾을때 헤매곤 했는데, 명확한 기준을 배워서 많은 도움이 되었다.\n\n## JS 리팩토링\n\n### 억지로 삼항 연산자(Ternary Operator)를 사용하려고 하지말 것\n예를 들어 아래와 같은 상황에서, includes 메서드와 e.target.value.length >= 8이란 표현식은 어차피 boolean을 반환하는데 삼항 연산자로 반환 값을 true or false로 지정할 필요가 없다.\n짧은 코드가 멋있어보이고, 뭔가 초보적으로 보이는 if..else는 안쓰려고 했던 내 마음을 들켜버린것 같았다.\n// 주석 처리된 것이 수정 전\n\nform.addEventListener('input', e => {\n  if (e.target.type === 'text') {\n    // isValid.id = e.target.value.indexOf('@') !== -1 ? true : false;\n    isValid.id = e.target.value.includes('@');\n  }\n  if (e.target.type === 'password') {\n    // isValid.pw = e.target.value.length >= 8 ? true : false;\n    isValid.pw = e.target.value.length >= 8;\n  }\n  validUI(isValid);\n});\n\n### 짧은 네이밍에 집착하지 말고 정확한 의미를 전달할 수 있도록 만들 것\n줌 인터랙션에 사용된 객체명이 수 많은 조건문에서 사용되어서 boundary를 bor로 줄였는데, 다른 사람이 보기에 이게 뭐하는 객체인지 쉽게 알 수 있는 객체명이 좋다고 권고되었다. 따라서 bor를 boundary로 다시 고쳤다. 다시 보니 굳이 줄일 필요 없었는데 짧고 간결한 네이밍에 집착했었던 것 같다.\n  // 수정 전\nconst bor = { xMin: 153, xMax: 297, yMin: 117, yMax: 353 };\n  \n  // 수정 후\nconst boundary = { xMin: 153, xMax: 297, yMin: 117, yMax: 353 };\n\n\n\n내용이 너무 많아져서 글은 여기서 끊었다.\n데모 :\n위스타벅스: 로그인 페이지\n위스타벅스: 음료 리스트 페이지\n위스타벅스: 음료 상세 페이지\n\n\nⓒ Wonkook Lee\n참고한 해당 홈페이지의 리소스와 음료 사진의 모든 저작권은\n스타벅스 코리아에게 있으며 문제가 생길 시 즉시 조치하겠습니다.\n🙏🏻 잘못된 정보가 있다면 지적해주세요"
  },
  {
    "title": "웹페이지 HTML 구조 한눈에 보는 꼼수",
    "summary": "HTML은 쉬우면서도 어렵다. 맥락에 맞게 군더더기 없이 시맨틱 태그를 잘 활용해서 작성해야 한다. HTML 작성을 잘 한다는 것은 마치 탄탄한 글을 쓰는 것과 같다.마음에 드는 페이지가 있고, 레이아웃을 참고하고 싶은데 각 컴포넌츠를 몇 Depth까지 구현했는지 개발",
    "link": "https://velog.io/@oneook/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-HTML-%EA%B5%AC%EC%A1%B0-%ED%95%9C%EB%88%88%EC%97%90-%EB%B3%B4%EB%8A%94-%EA%BC%BC%EC%88%98",
    "img_link": "https://media.vlpt.us/images/oneook/post/f5c0b4f9-e78d-4ad1-b6d8-b240a532f2c0/thumbnail_kor.jpg?w=768",
    "content": "웹페이지 HTML 구조 한눈에 보는 꼼수\n이 페이지 어떻게 만들었지?\nHTML은 쉬우면서도 어렵다. 맥락에 맞게 군더더기 없이 시맨틱 태그를 잘 활용해서 작성해야 한다. HTML 작성을 잘 한다는 것은 마치 탄탄한 글을 쓰는 것과 같다.\n마음에 드는 페이지가 있고, 레이아웃을 참고하고 싶은데 각 컴포넌츠를 몇 Depth까지 구현했는지 개발자 도구 Elements 탭에서 일일히 들여다본적이 있는가? 그렇다면 당신은 나와 같다.\n웹 페이지 클론 코딩할때 가끔 써먹었던 나의 꼼수를 아래에 소개한다.\n\n\n모든 HTML 구조 한 눈에 보기\n원리라고 하기에도 별 것 없어서 팁 대신 꼼수라는 단어를 사용했다. 그저 모든 태그 요소를 DOM으로 조작하여 테두리를 넣어주는 방법이다. 복잡한 페이지의 각 요소별 영역 구획과 hierarchy를 눈으로 확인하기 쉬워진다.\n각 요소별로 색상을 다르게 해서 볼 수도 있다. 같은 방법으로 마켓 컬리의 구조도 바꿔보겠다.\n\n\n하는 방법\n크롬을 사용한다면 보고 싶은 웹 페이지에 들어가서 개발자 도구를 열고, Console 탭에서 아래 코드를 붙여 넣어주면 된다. 웹 페이지에서 레이아웃 잡을때 흔하게 사용되는 태그들을 입력했고, 추가 하거나 빼고 싶은 태그가 있다면 첨삭해서 사용하면 된다.\ndocument.querySelector('*').style.boxSizing = 'border-box';\ndocument.querySelectorAll('div').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('span').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('ul').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('li').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('dd').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('dl').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('dd').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('section').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('h1').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('a').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('img').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('form').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('button').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('header').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('footer').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('input').forEach(e => e.style.border = \"1px solid dodgerblue\");\ndocument.querySelectorAll('p').forEach(e => e.style.border = \"1px solid dodgerblue\");\n\n\n@phw3071 님께서 올려주신 개선된 코드\n['div', 'span', 'ul', 'li', 'dd', 'dl', 'section', 'h1', 'a', 'img', 'form', 'button', 'header', 'footer', 'input', 'p'].forEach(e => {\n    document.querySelectorAll(e).forEach(element => {\n        element.style.outline = \"1px solid dodgerblue\"\n    })\n})\nphw3071님께서 개선된 코드를 작성해주셔서 소개해드립니다.\nborder를 사용하면 레이아웃이 깨지는데 반해 (특히 그리드형 레이아웃) outline은 box model의 변화 없이 영역을 확인할 수 있어 더 없이 좋은 선택이 될 것 같습니다.\n기여해주신 phw3071님께 감사드립니다.\n\n\n글과 그림 ⓒ Wonkook Lee\n🙏🏻 잘못된 정보가 있다면 지적해주세요"
  }
]